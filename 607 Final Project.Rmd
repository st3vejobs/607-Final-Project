---
title: "Exploring the Universe"
author: "Shane Hylton"
date: "12/4/2021"
output:
  prettydoc::html_pretty:
    toc: true
    toc_collapsed: true
    theme: cayman
    highlight: github
toc-title: "Table Of Contents"
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(plotly)
```

## Sloan Digital Sky Survey

The Sloan Digital Sky Survey (SDSS) is an ongoing astronomical survey that seeks to map as much of the observable universe as possible. It is the largest astronomical mapping project ever undertaken. Upon completion, SDSS figures to possess 15 terabytes of data on the universe and the billions of stars within it. The SDSS has a full [about page](http://skyserver.sdss.org/dr7/en/sdss/) that is approachable to people of all backgrounds.


## Data Collection

The data is held in a publicly accessible database that can be searched using SQL commands. The data I will be using is obtained from queries performed on the SDSS SkyServer website.  

The first dataset that I collected deals specifically with stars. Because the data are stored in many different tables, it was important to use SQL to join multiple tables to obtain all of the data I wanted.

### 2500 Objects from SEGUE 1: 

[SEGUE](https://www.sdss.org/surveys/segue/) stands for Sloan Extension for Galactic Understanding and Exploration.

#### Query:

SELECT top 2500
sp.plate, sp.mjd, sp.fiberid, sp.specobjid, sp.bestobjid,
sp.elodiervfinal, sp.teffadop, sp.fehadop, sp.loggadop, sp.teffspec, sp.fehspec,
ph.psfmag_g, ph.psfmag_r, ph.psfmag_i,
ph.psfmagErr_g, ph.psfmagErr_r, ph.psfmagErr_i, ph.ra,ph.dec,ph.u,ph.g,ph.r,ph.i,ph.z, 
s.specobjid, s.class, s.subclass, s.z, s.plate, s.mjd, s.fiberid, s.elodieBV, s.elodieTEff, s.elodieLogG, s.elodieFeH, s.elodieZ, s.elodieZErr

FROM sppParams AS sp
JOIN PhotoObjAll AS ph ON sp.bestobjid = ph.objid
JOIN SpecObj AS s ON ph.objid = s.bestobjid
WHERE sp.seguePrimary = 1
AND sp.teffadop != -9999


### Wider Data Frame of 10,000 Objects from SEGUE 1 and 2


#### Query:

SELECT top 10000
sp.plate, sp.mjd, sp.fiberid, sp.specobjid, sp.bestobjid,
sp.elodiervfinal, sp.teffadop, sp.fehadop, sp.loggadop, sp.teffspec, sp.fehspec,
ph.psfmag_u, ph.psfmag_g, ph.psfmag_r, ph.psfmag_i, ph.psfmag_z,
ph.psfmagErr_u, ph.psfmagErr_g, ph.psfmagErr_r, ph.psfmagErr_i, ph.psfmagErr_z, ph.ra,ph.dec,ph.u,ph.g,ph.r,ph.i,ph.z, ph.Fiber2mag_u,
s.specobjid, s.class, s.subclass, s.z, s.plate, s.mjd, s.fiberid, s.elodieBV, s.elodieTEff, s.elodieLogG, s.elodieFeH, s.elodieZ, s.elodieZErr

FROM sppParams AS sp
JOIN PhotoObjAll AS ph ON sp.bestobjid = ph.objid
JOIN SpecObjAll AS s ON ph.objid = s.bestobjid
WHERE sp.teffadop != -9999




I chose to filter out any values where the effective adopted temperature was undefined. Further wrangling is necessary to filter out missing or incorrect values. 


## Loading the Data

```{r}

link <- 'https://raw.githubusercontent.com/st3vejobs/607-Final-Project/main/10000_sdss_joined.csv'
starsraw <- read.csv(url(link), na.strings = "")

```

### Tidying

Any entries of -9999 represent NA values. Galaxies and quasars are not objects of interest in this exploration, so they will be omitted. The data obtained from the SQL query should contain mostly stars, but the steps below will confirm that only stars are being considered.

```{r}

starsna <- starsraw
starsna[starsna == -9999 ] <- NA
starstidy <- starsna %>% na.omit(starsna)

starsfull <- starstidy %>%
  filter(class == "STAR")

```

Next, I removed columns that were either redundant or unnecessary to the task at hand. 

```{r}

stars <- subset(starsfull, select = -c(plate, specobjid, fiberid, plate1, fiberid1, specobjid1, mjd1))

```

Further, I converted the modified Julian Date to the standard Julian Date. Because modified Julian Dates can be stored as integers or floating point numbers, they are widely used in astronomy for ease of access in datasets. I learned about MJD from [Wolfram](https://scienceworld.wolfram.com/astronomy/ModifiedJulianDate.html).

```{r}

stars$date <- format(as.POSIXct('1858-11-17')+(stars$mjd*24*60*60),"%m-%d-%Y")

```

The final step in the tidying process was to rearrange the columns to make viewing the data more efficient.

```{r}

stars <- stars %>% 
  relocate(date, .after = mjd)

stars <- stars %>% 
  relocate(bestobjid, elodiervfinal, .after = elodieZErr)

stars <- stars %>% 
  relocate(subclass,teffadop, teffspec, elodieTEff, fehadop, fehspec, elodieFeH, .after = date)

stars <- stars %>% 
  relocate(ra,dec,u,g,r,i,z, .after = fehspec)

stars <- stars %>%
  mutate_if(is.numeric, round, digits = 6)

stars <- stars %>%
  rename(redshift = z1)

```

## Data Manipulation

Using the multiple different methods of temperature and Iron to Hydrogen (Fe/H) ratio calculation, I will add an aggregate column that pulls from multiple calculation methods. Fe/H is also known as metallicity.

```{r}

stars <- stars %>%
  mutate(temp = (teffadop + teffspec)/2)

stars <- stars %>%
  mutate(metallicity = (fehadop + fehspec)/2)

stars <- stars %>%
  relocate(temp, .before = teffadop)

stars <- stars %>%
  relocate(metallicity, .after = temp)

```

### Subsetting

Next, I will create multiple long, tidy dataframes to support analysis goals.

#### Hertzprung-Russell Diagrams and Absolute Magnitude

One challenge of this dataset is that in order to approximate absolute magnitude best, it is important to choose the right filter between the u'g'r'i'z filters on the telescope. I will choose filters for each star based on which filter provides the lowest error in magnitude. 

u: ultraviolet | g: green | r: red | i: near infrared | z: infrared

Originally, I was going to create a typical Hertzprung-Russell diagram with absolute magnitude on the y-axis and B-V on the x-axis. Because SDSS uses a different system for storing their values, I cannot calculate the absolute magnitude for each star. I have attempted to go through as much of the data as I could on their website, and I cannot find any measure of distance, which is needed in order to compute absolute magnitudes. Hubble's Law would allow for distance calculations if the stars in question were all distant galaxies, but it cannot be used for nearby stars. Because of this, I will have to make an improvised HR diagram using the optimum magnitude filter and the BV values. 

The key issue here is that the absolute magnitudes of each star are not known, which makes it impossible to accurately produce an HR diagram. The closer a star is, the brighter it will appear, which will significantly skew the data. 

```{r}

HR <- subset(stars, select = c(class, elodieBV))
HR$mag <- NA

for (idx in 1:nrow(stars)){
  if (stars[idx, ]$psfmagErr_u <= stars[idx, ]$psfmagErr_g  && stars[idx, ]$psfmagErr_u  <= stars[idx, ]$psfmagErr_r  && stars[idx, ]$psfmagErr_u  <= stars[idx, ]$psfmagErr_i  && stars[idx, ]$psfmagErr_u  <= stars[idx, ]$psfmagErr_z){
    HR[idx, ]$mag <- stars[idx, ]$psfmag_u
  }
  if (stars[idx, ]$psfmagErr_g <= stars[idx, ]$psfmagErr_u  && stars[idx, ]$psfmagErr_g  <= stars[idx, ]$psfmagErr_r  && stars[idx, ]$psfmagErr_g  <= stars[idx, ]$psfmagErr_i  && stars[idx, ]$psfmagErr_g  <= stars[idx, ]$psfmagErr_z){
    HR[idx, ]$mag <- stars[idx, ]$psfmag_g
  }
  if (stars[idx, ]$psfmagErr_r <= stars[idx, ]$psfmagErr_g  && stars[idx, ]$psfmagErr_r  <= stars[idx, ]$psfmagErr_g  && stars[idx, ]$psfmagErr_r  <= stars[idx, ]$psfmagErr_i  && stars[idx, ]$psfmagErr_r  <= stars[idx, ]$psfmagErr_z){
    HR[idx, ]$mag <- stars[idx, ]$psfmag_r
  }
  if (stars[idx, ]$psfmagErr_i <= stars[idx, ]$psfmagErr_g  && stars[idx, ]$psfmagErr_i  <= stars[idx, ]$psfmagErr_r  && stars[idx, ]$psfmagErr_i  <= stars[idx, ]$psfmagErr_u  && stars[idx, ]$psfmagErr_i  <= stars[idx, ]$psfmagErr_z){
    HR[idx, ]$mag <- stars[idx, ]$psfmag_i
  }
  if (stars[idx, ]$psfmagErr_z <= stars[idx, ]$psfmagErr_g  && stars[idx, ]$psfmagErr_z  <= stars[idx, ]$psfmagErr_r  && stars[idx, ]$psfmagErr_z  <= stars[idx, ]$psfmagErr_i  && stars[idx, ]$psfmagErr_z  <= stars[idx, ]$psfmagErr_u){
    HR[idx, ]$mag <- stars[idx, ]$psfmag_z
  }
}

```


```{r}
ggplot(HR)+
  geom_point(aes(x = elodieBV, y = mag))+
  scale_y_reverse(lim = c(26,10))

```


Notes to self

absolute magnitude can be any of the five ugriz filtered magnitudes. They may need to be adjusted depending on the star being studied. 
u,g,r,i,z are all filters on the telescope
the filters are not exact, but they provide decent estimates. 
it may be fine to just average ugriz magnitudes to come up with one number to go with
for HR we need abs mag and b-v increasing on the x axis

## Stellar Classification

Many of the stars in the stars dataframe have classes assigned to them that do not align with the effective temperatures. I will reassign the stars to new classes based on temperature.
The subclass for each star is determined by a set of parameters found on [this page](https://www.sdss.org/dr12/algorithms/segue_target_selection_details/#kd)

```{r}

stars$shane_class <- NA
stars <- stars  %>% 
  relocate(shane_class, .after = subclass)
summary(stars$temp)

for (idx in 1:nrow(stars)){
  if (stars[idx, ]$temp >= 4000 && stars[idx, ]$temp < 5000){
    stars[idx, ]$shane_class <- 'canadian'
  }
  if (stars[idx, ]$temp >= 5000 && stars[idx, ]$temp < 5750){
    stars[idx, ]$shane_class <- 'chilly'
  }
  if (stars[idx, ]$temp >= 5750 && stars[idx, ]$temp < 6250){
    stars[idx, ]$shane_class <- 'sunny'
  }
  if (stars[idx, ]$temp >= 6250 && stars[idx, ]$temp < 7000){
    stars[idx, ]$shane_class <- 'tropical'
  }
  if (stars[idx, ]$temp >= 7000 && stars[idx, ]$temp < 8000){
    stars[idx, ]$shane_class <- 'equatorial'
  }
  if (stars[idx, ]$temp >= 8000 && stars[idx, ]$temp < 9000){
    stars[idx, ]$shane_class <- 'deadly'
  }
}
```

## Better HR Diagram Data?

## RA/Dec Map

```{r}

ggplot(stars)+
  geom_point(aes(x = ra, y = dec, color = shane_class))

```

### 3D Plot of Stars using plot_ly ( )

I will use plotly to construct a 3d plot of the stars in the stars data frame with redshift as the z-axis. 

```{r}

plot_ly(stars, x = stars$ra, y = stars$dec, z = stars$redshift, color = stars$shane_class) %>%
  add_markers()

```

#### Star population by shane_class:

```{r}

classcount <- data.frame(table(stars$shane_class))
colnames(classcount) <- c('class', 'population')
ref <- c(1,2,6,5,3,4)
classcount <- classcount %>%
  add_column(ref)
classcount <- classcount %>%
  arrange(ref)


ggplot(classcount, aes(x = ref, y = population, fill = class))+
  geom_col()+
  ylab('Population')+
  xlab('Shane Class')+
  ggtitle('Temperature Distribution of 10,000 Stars')+
  geom_text(
    aes(label = population),
    vjust = 2
  )+
  scale_x_discrete(limits =1:6, labels = c("1" = "Canadian","2" = "Chilly", "3" = "Sunny","4" = "Tropical","5" = "Equatorial", "6" = "Deadly"))+
  theme(plot.title = element_text(hjust = 0.5))

```

This plot reveals that of the 10,000 stars selected, the highest populated subcategory shares an effective temperature like that of the sun. 

## Temperature Distribution

```{r}

ggplot(stars, aes(x=temp))+
  geom_histogram(aes(y=..density..), color = 'blue4', fill = 'darkorchid3', binwidth = 150)+
  geom_density(alpha=.2, fill = 'darkgreen')+
  ggtitle('Temperature Distribution of 10,000 Stars')+
  theme(plot.title = element_text(hjust = 0.5))+
  xlab('Temperature')+
  ylab('Density')

```

The distribution of the temperatures of the stars in this sample appears to be near normal. It can be further examined to see that from 5200-6600 K, there is a much more normal distribution. 
```{r}

stars_trim <- subset(stars, temp >= 5200 & temp <= 6600)


ggplot(stars_trim, aes(x=temp))+
  geom_histogram(aes(y=..density..), color = 'blue4', fill = 'darkorchid3', binwidth = 75)+
  geom_density(alpha=.2, fill = 'darkgreen')+
  ggtitle('Temperature Distribution of 10,000 Stars')+
  theme(plot.title = element_text(hjust = 0.5))+
  xlab('Temperature')+
  ylab('Density')

```


## Relationship Exploration

I will now take the stars data and plot variables against one another to see which variables are correlated. 

```{r}

stars <- subset(stars, temp >= 5200 & temp <= 6600)

ggplot(stars, aes(x = metallicity, y = temp, na.rm = TRUE))+
  geom_point(na.rm = TRUE, color = 'deepskyblue')+
  geom_smooth(color = "green")+
  geom_smooth(method = "lm", color = "red")+
  ggtitle("Relationship Between Metallicity and Temperature")+
  xlab("Metallicity")+
  ylab("Temperature")+
  theme(plot.title = element_text(hjust = 0.5, size = 10))

```
### Is there a strong relationship between temperature and magnitude in this sample?


```{r}


ggplot(stars, aes(x = temp, y = HR$mag, na.rm = TRUE))+
  geom_point(na.rm = TRUE, color = 'darkorchid4')+
  geom_smooth(color = "azure4")+
  geom_smooth(method = "lm", color = "red", se = FALSE)+
  ggtitle("Relationship Between Temperature and Magnitude")+
  xlab("Temperature")+
  ylab("Magnitude")+
  theme(plot.title = element_text(hjust = 0.5, size = 10))

```
This plot is a return to the previous issue presented, the magnitudes are not absolute, which could impact conclusions. There is, however, some very minor evidence of a linear relationship between the two variables. The slope of the fitted line appears to be near zero, which would lead to a nearly constant prediction for magnitude given a temperature. 

```{r}

fit <- lm(HR$mag ~ temp, data = stars)
summary(fit)

set.seed(16)
x <- runif(1, min(stars$temp), max(stars$temp))
eq <- .00009165*x + 16.72

paste("Predicted Magnitude value for a given temperature such as: ", round(x, 3), "Magnitude: ", round(eq, 3))


idx <- as.numeric(which.min(abs(x - stars$temp)))
near <- stars$temp[idx]
near
resid <- eq - HR$mag[idx]
paste("Residual: ", resid)
```

For a given temperature of 7374.044 K, the prediction based on the linear regression model for the magnitude of the star is underestimated by 0.66239 when compared to the actual value for a star with a temperature of 7373.55 K. This appears to be a reasonably accurate predicted value. 
```{r}

ggplot(data = fit, aes(x = .fitted, y = .resid)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed", color = 'red') +
  xlab("Fitted values") +
  ylab("Residuals") +
  ggtitle("Linearity of Residuals")+
  theme(plot.title = element_text(hjust = 0.5))

```
The residuals plot is relatively constantly variable around the axis, with significant clustering between magnitudes 17.2 and 17.3.

```{r}

ggplot(data = fit, aes(x = .resid)) +
  geom_histogram(binwidth = 0.5) +
  xlab("Residuals") +
  ggtitle("Histogram of Residuals")+
  theme(plot.title = element_text(hjust = 0.5))

```

The histogram of the residuals shows an ever-so-slight left skew, but for the most part it reveals a mostly normal distribution. 

```{r}

ggplot(data = fit, aes(sample = .resid)) +
  stat_qq()+
  ggtitle("Normal Probability Plot of Residuals")+
  theme(plot.title = element_text(hjust = 0.5))

```

The normal probability plot shows a strong linear relationship, with a significant divergence at the higher end of the plot. This is similar to the relationship between magnitude and temperature on Hertzprung-Russell Diagrams, where there is a partially linear relationship between temperature and absolute magnitude among main-sequence stars, with divergence at either end of the spectrum. 


## Hertzprung-Russell Diagram with a New Dataset

The new dataset I will be using for the accurate Hertzprung-Russell Diagram was found on [Kaggle](https://www.kaggle.com/brsdincer/star-type-classification).

```{r}

link <- 'https://raw.githubusercontent.com/st3vejobs/607-Final-Project/main/nasa_HR_set.csv'
hr <- read.csv(url(link), na.strings = "")
hr_main <- 1
  
  
ggplot(hr, aes(x = Temperature, y = L))+
  geom_point()+
  scale_x_reverse(lim = c(40000,1000))+
  coord_trans( y = "log10")

```






## Source Links


https://www.sdss.org/dr12/algorithms/magnitudes/#mag_psf

https://watermark.silverchair.com/424-2-1584.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAAtgwggLUBgkqhkiG9w0BBwagggLFMIICwQIBADCCAroGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMol7AiO2UYLLN1fQ_AgEQgIICiyht0NuoiTK1BuF4dLkzHxJakrb_Nyl9e6PknPXU4RohBF5SyuGyMLIh7yMP3CskmJ8gpDS7z2q9XQnskBIf_QDZ-N_nl7ZX8sfIK45SGpW5mbVongHGXRl9GtV5phwvc6PlZZTUq2BtmOoxU6_7ulDTZ-0zF6YpapowU96cnmBY7UG6OYyuJsiAFNUO5ZreARBUwggqDKYiF_s6suiYbg_AxCwDGl1dxC_mPVT85HNhrhLmXSypoTPJfQEr6tB68IdTJrERtzUKowNa3lFrasEkYQjKAUwUmZdyC9xgR8CDgvKTGSTAmmOOzaVOkk9krxAMRvDimISDg-6_stvoWbYb2gyMwQGTP2m4g2suv96NZcDwxmzQsm9da2GkRtT-hUawj6LJFfS631ezxOa3ORhKi_Rk18wGrO73FN8MKuW-vCRZEa_uHvIUhJ2SbWeSvKeRUOcJr1cir2LkDL3VyDEaKIWM6TadO1EMTDFjbiJhsOgY_mSLCSBgdYKiTWCURq-Is-AS3qsCtjJw3N860VoqIuirEpSMaRVFsF2rpqe18lSdcgbEo9FHTJ83g6CKDZ_NCNg5GjrTWhxtWAKz5cRfCXFXStCrZbsQz6aD6VbcNkqS2sDOT1LlCU2_DcezhOGE4pCwRRM71jWn2mz56zBhFyws3F1cBwER4CBMOijqBGjkHi4AH7DAeIMOIeqlBukZUvr-p0kJt_a3DKOaMlB8hhSSuCOcXr3APDF3w30WcavQu_K4slsTJgclJr27Y8oTBtmSydsW5-RnLFmEhk5jN3E7JF7YkE9MHuyPCMTPIRPY7_HCzspGWKTZDAe_jHcjoUlL9e3Ti0Swyg-51bD_hZqDLv_lWnupkA



https://skyserver.sdss.org/dr1/en/proj/advanced/color/sdssfilters.asp


https://www.kaggle.com/brsdincer/star-type-classification



